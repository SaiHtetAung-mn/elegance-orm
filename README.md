# Elegance ORM

Elegance ORM is a minimalist object relational mapper (ORM) for Node.js projects. The interface emphasizes fluent, chainable methods so querying, filtering and shaping results stays conversational rather than imperative. In Elegance, each database
table is represented by a `Model` class that behaves like a plain object with dirty tracking,
fillable/guarded protection, and timestamp helpers. If you enjoy Laravel’s ergonomics, you’ll feel at home.

---

## 1. Overview
- **Drivers:** PostgreSQL (`pg`), MySQL / MariaDB (`mysql2`), and SQLite (`sqlite3`).
- **Language targets:** Works in both TypeScript and JavaScript projects (Node.js 18+).
- **Design goals:** Fluent builder APIs, fillable/guarded protection, timestamp helpers, expressive schema blueprints, and zero-magic data sources.

---

## 2. Installation & Requirements
```bash
npm install elegance-orm
```

- Requires **Node.js 18+**
- The CLI binary is `elegance` (available via `npx elegance ...` or `npm install -g elegance-orm`).

---

## 3. Quick Start

### Step 1 – Initialize a project
```bash
npx elegance init
```
Generates `elegance.config.ts` and scaffolds folders for migrations/models.

### Step 2 – Configure the DataSource
```ts
// src/database/dataSource.ts
import { DataSource } from "elegance-orm";

const dataSource = new DataSource({
  driver: "postgresql",           // "postgresql" | "mysql" | "sqlite"
  host: "127.0.0.1",
  port: 5432,
  user: "app_user",
  password: "secret",
  database: "app_db",
  maxPoolSize: 10
});

export default dataSource;
```

### Step 3 – Initialize the connection
```ts
import dataSource from "./database/dataSource";

await dataSource.initialize();
```

### Step 4 – Define a model
```ts
import { Model } from "elegance-orm";

export default class User extends Model {
  protected table = "users";
  protected primaryKey = "id";
  protected fillable = ["name", "email", "status"];
  protected hidden = ["password"];
}
```

### Step 5 – Run your first query
```ts
const activeUsers = await User.query()
  .select("id", "name", "email")
  .where("status", "=", "active")
  .orderByDesc("created_at")
  .limit(10)
  .get();

const user = await User.create({ name: "Ada", email: "ada@example.com", status: "active" });
user.status = "inactive";
await user.save();
```

---

## 4. Models
In Elegance, every database table is represented by a related “Model” that handles interactions with that table. Beyond fetching data, Elegance models also let you create, modify and remove records in the table. Models extend `Model` and represent a single table. They behave like plain objects wrapped in a proxy so attribute reads/writes automatically respect guardrails.

### Guardrails & Identity
- `table` – physical table backing the model.
- `primaryKey` – defaults to `"id"`, but can be any column.
- `fillable` – whitelist for mass assignment.
- `guarded` – blacklist (set to `["*"]` to deny everything by default).
- `hidden` – attributes excluded when calling `toJSON()`.
- `timestamps` – enable/disable automatic `created_at` / `updated_at`.
- `CREATED_AT` / `UPDATED_AT` – override these names if your schema differs.

```ts
class Article extends Model {
  protected table = "articles";
  protected fillable = ["title", "body", "status"];
  protected guarded = ["user_id", "is_admin"];
  protected hidden = ["user_id"];
}
```

### Mass Assignment
```ts
await Article.create({
  title: "Hello",
  body: "World",
  status: "draft",
  is_admin: true // throws MassAssignmentException
});
```

Set `guarded = ["*"]` and explicitly list what is safe in `fillable` when consuming untrusted payloads.

### Lifecycle
- `Model.create(attributes)` – insert one record immediately.
- `model.save()` – insert (if new) or only update dirty columns.
- Dirty tracking is automatic, so `save()` only sends changed fields.
- Timestamps populate automatically when `timestamps = true`.

---

## 5. Query Builder
The builder provides a fluent interface for composing SQL while retaining parameter binding safety.
Inspect the generated SQL via `toSql()` to see the final statement and placeholders.
<br/>

Let's see how raw sql is generated by below code:

```ts
const builder = User.query("u")
  .select("u.id", "u.name", "profiles.bio")
  .leftJoin("profiles", "u.id", "=", "profiles.user_id")
  .where("u.status", "=", "active")
  .whereBetween("u.created_at", ["2024-01-01", "2024-12-31"])
  .orderBy("u.created_at", "desc")
  .offset(0)
  .limit(5);

console.log(builder.toSql());
```
<br/>

Sample raw SQL output
```sql
select "u"."id", "u"."name", "profiles"."bio"
from "users" as "u"
left join "profiles" on "u"."id" = "profiles"."user_id"
where "u"."status" = ?
and "u"."created_at" between ? and ?
order by "u"."created_at" desc
limit 5 offset 0
```

### Selecting
- `select(...columns)` / `addSelect(...columns)`
- `distinct()`
- `toSql()`

```ts
User.query("u")
  .select("u.id", "u.email")
  .distinct()
  .toSql(); // inspect generated SQL
```

### Filtering
- `where`, `andWhere`, `orWhere`
- `whereIn` / `whereNotIn`
- `whereBetween` / `whereNotBetween`
- `whereNull` / `whereNotNull`

```ts
await User.query()
  .where("status", "=", "active")
  .whereIn("role", ["admin", "editor"])
  .whereBetween("created_at", ["2024-01-01", "2024-12-31"])
  .get();
```

### Joins
- `join` (inner), `leftJoin`
- Accepts table aliases, custom operators, and multiple clauses.

```ts
await Post.query("p")
  .leftJoin("users as u", "p.user_id", "=", "u.id")
  .select("p.id", "p.title", "u.name as author")
  .get();
```

### Grouping & Aggregates
- `groupBy`, `having`
- Aggregate helpers: `count`, `sum`, `avg`, `min`, `max`

```ts
const summary = await Order.query()
  .select("status")
  .groupBy("status")
  .having("status", "!=", "archived")
  .get();
```

### Ordering & Pagination
- `orderBy`, `orderByDesc`
- `latest`, `oldest`
- `limit`, `offset`

```ts
await Article.query()
  .latest("published_at")
  .limit(10)
  .offset(page * 10)
  .get();
```

### Fetching Helpers
- `get()` – all rows.
- `first()` – first row or `null`.
- `find(id)` – shorthand for PK lookup.

### Mutations
- `create(attributes)` – returns inserted row as model.
- `insert(records[])` – bulk insert via builder and **skips** fillable checks.
- `insertGetId(attributes)` – single row insert returning the generated key.
- `update(attributes)` – updates rows matching current builder constraints.
- `delete()` – deletes rows matching current builder constraints.

```ts
await User.query().insert([
  { name: "Bulk One", email: "bulk1@example.com" },
  { name: "Bulk Two", email: "bulk2@example.com" }
]);
```

---

## 6. Schema & Migrations
Migrations act like a shared change log for your database, helping teams track, apply, and synchronize schema changes over time. Migrations extend the `Migration` base class to describe tables in plain
language which Elegance compiles to driver-specific SQL.

### Creating Migrations
```bash
npx elegance make:migration create_users_table --table=users --create
npx elegance make:migration update_users_table --table=users --update
```

Use `--create` to scaffold a `Schema.create` migration for a new table, and `--update` to scaffold a `Schema.table` migration when you only need to modify an existing table. Pair either flag with `--table=<name>` or follow the `create_users_table` naming convention so the table can be inferred automatically.

### Migration Structure
A migration class contains two methods: up and down. The up method is used to add new tables, columns, or indexes to your database, while the down method should reverse the operations performed by the up method.

```ts
import { Migration, Schema } from "elegance-orm";

export default class CreateUsersTable extends Migration {
  async up() {
    await Schema.create("users", table => {
      table.id();
      table.string("name");
      table.string("email").unique(["email"]);
      table.string("status").default("pending");
      table.timestamps();
      table.integer("role_id");
      table.foreign("role_id")
           .references("id")
           .on("user_roles")
           .onDelete("cascade");
    });
  }

  async down() {
    await Schema.dropIfExists("users");
  }
}
```

### Schema API Highlights
- `Schema.create(table, callback)`
- `Schema.table(table, callback)`
- `Schema.drop(...)`, `Schema.dropIfExists(...)`
- `Schema.renameColumn(table, from, to)`
- `Schema.dropColumns(table, columns)`
- `Schema.hasTable(table)`, `Schema.hasColumn(table, column)`

### Column Helpers
- IDs: `id`, `increment`, `bigIncrement`, `smallIncrement`
- Integers: `integer`, `bigInteger`, `smallInteger`
- Text: `char`, `string`, `text`, `longText`
- Dates: `date`, `dateTime`, `time`, `timestamp`, `year`, `timestamps()`
- JSON & binary: `json`, `binary`
- Boolean: `boolean`
- UUID: `uuid`

### Indexes & FK Constraints
- `primary`, `unique`, `index`, `dropPrimary`, `dropUnique`, `dropIndex`
- `foreign(column).references(column).on(table).onDelete("cascade").onUpdate("cascade")`

### Running migration:
To run migrations

```bash
npx elegance migrate
```

### Rolling back migration:
To roll back the latest migrations, use

```bash
npx elegance migrate:rollback
```

### Roll back and migrate using a single command
This command will roll back all migrations and recreate entire database tables.

```bash
npx elegance migrate:refresh
```

---

## 7. Recipes

### Bulk Insert with Guarded Columns
```ts
await User.query().insert([
  { name: "Bulk One", email: "bulk1@example.com" },
  { name: "Bulk Two", email: "bulk2@example.com" }
]);
```
Useful when syncing fixtures or importing CSV data. Because it bypasses `fillable`, validate your payload first.

### Raw Queries via DataSource
```ts
import dataSource from "./database/dataSource";
import User from "./app/models/User";

await dataSource.initialize();
const rows = await dataSource.rawQuery(
  "select * from users where email like ?",
  ["%example.com"]
);
await dataSource.insert(
  "insert into audit_log (payload) values (?)",
  [JSON.stringify(rows)]
);
await dataSource.destroy();
```

### Transactions
Database transactions are used to execute a set of database operations as a single unit of work ensuring data integrity. Elegance provides transaction management via datasource. Any query builder or model helpers you call inside the callback automatically share the same transaction context.

```ts
await dataSource.transaction(async trx => {
  await trx.insert(
    "insert into orders (user_id, total) values (?, ?)",
    [userId, total]
  );

  await trx.update(
    "update users set last_order_total = ? where id = ?",
    [total, userId]
  );

  await User.create({ name: "Tx example", email: "tx@example.com" });
});
```

### Conditional Migrations
```ts
if (!(await Schema.hasTable("settings"))) {
  await Schema.create("settings", table => {
    table.id();
    table.string("key").unique(["key"]);
    table.string("value");
    table.timestamps();
  });
}
```

### Available Methods
- `destroy`
- `rawQuery`
- `select`
- `insert`
- `update`
- `delete`
- `transaction`

---

## 8. CLI Reference
Elegance ships a CLI binary named `elegance`. After installing
the package you can:

- run commands directly with `npx elegance <command>` (local install), or
- install globally (`npm install -g elegance-orm`) and call `elegance <command>`.

Run the `init` command once per project to scaffold `elegance.config.ts`.

| Command | Description | Options |
| --- | --- | --- |
| `init` | Scaffold `elegance.config.ts` in the project root. | – |
| `make:migration <name>` | Generate a timestamped migration. | `--table=users`, `--create`, `--update` |
| `make:model <path>` | Create a model file inside the configured directory. | Supports nested paths (`Admin/User`) |
| `migrate` | Run all pending migrations. | – |
| `migrate:rollback` | Roll back the latest batch. | – |
| `migrate:refresh` | Drop all tables and rerun every migration. | – |

---

## 9. Configuration Reference

`elegance.config.ts` tells the CLI where to find your DataSource, migrations, and models.

```ts
import dataSource from "./src/database/dataSource";

const config = {
  dataSource: "./src/database/dataSource",
  migrations: {
    directory: "./database/migrations",
    table: "migrations"
  },
  models: {
    directory: "./src/app/models"
  },
  language: "typescript"
};

export default config;
```

| Key | Description |
| --- | --- |
| `dataSource` | Path to a module exporting a `DataSource` instance. |
| `migrations.directory` | Folder where migration files live. |
| `migrations.table` | Table Elegance uses to track executed migrations (defaults to `migrations`). |
| `models.directory` | Destination for `make:model`. Can be nested. |
| `language` | `"typescript"` or `"javascript"` – controls CLI templates. |

### DataSourceOptions
```ts
type ConnectionOptions = {
  driver: "mysql" | "postgresql" | "sqlite";
  host: string;
  port: number;
  user: string;
  password: string;
  database: string;
  maxPoolSize?: number;
};
```

For SQLite, set `host` to an empty string and `database` to a `.sqlite` file path.

⚠️ **Status**: <br/>
Elegance ORM is currently in beta and shared as an experimental project.
It is not yet intended for production use.
